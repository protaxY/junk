# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Волков М. А.
### номер в списке группы: 4

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Опишите своими словами, чем списки в языке Пролог отличаются от принятых в императивных языках подходов к хранению данных. На какие структуры
данных в традиционных языках похожи списки в Прологе?

Главные отличия списков на языке *prolog* от принятыв в императивных состоит в том, что к любому элементу, стоящему в середине списка,
можно получить быстрый доступ. В прологе сделать это на много труднее. В целом общение со списком данных, на мой субъективный взгляд,
очень сложное. Но это условности языка и с этим ничего поделать нельзя. 

## Описание стандартных предикатов
`len([],X)`
Пример использования:
```prolog
?- len([1,2,3,4,5],X).
X = 5.
```

Реализация:
```prolog
len([],0).
len([_|Y], N) :- len(Y,N1), N is N1 + 1.
```


`member(X,[])`
Пример использования:
```prolog
?- member(3,[1,2,3,4,5]).
true ;
false.

?- member(f,[1,2,3,4,5]).
false.
```

Реализация:
```prolog
member(A,[A|_]).
member(A,[_|Z]) :- member(A,Z).
```


`append([],[],L)`
Пример использования:
```prolog
?- append([1],[1,2,3],L).
L = [1, 1, 2, 3].
```

Реализация:
```prolog
append([], X, X).
append([A|X], Y, [A|Z]):- append(X,Y,Z).
```


`remove(X,[],L)`
Пример использования:
```prolog
?- remove(2,[1,2,3],L).
L = [1, 3] ;
false.
```

Реализация:
```prolog
remove(X,[X|T],T).
remove(X,[Y|T],[Y|T1]):- remove(X,T,T1).
```


`permute([],L)`
Пример использования:
```prolog
?- permute([a,b,c],L).
L = [a, b, c] ;
L = [a, c, b] ;
L = [b, a, c] ;
L = [b, c, a] ;
L = [c, a, b] ;
L = [c, b, a] ;
false.
```

Реализация:
```prolog
permute([],[]).
permute(L,[X|T]):- remove(X,L,R), permute(R,T).
```

## Задание 1.1: Предикат обработки списка

`deleteFitstN(N,[Y],[Z])` - удаляет первые N элементов из списка. Результат записывается в `[Z]`
Примеры использования:
```prolog
?- delFirstN(2,[1,2,3],L).
L = [3]

?- delFirstN(3,[1,2],L).
L = []
```

Реализация:
```prolog
delFirstN(0,L,L).
delFirstN(_,[],[]).
delFirstN(N,[_|H],L):- N > 0, N1 is N - 1, delFirstN(N1,H,L). 
```

На вход предикату поступают 3 переменные: 
1. N - количество элементов, которое нужно удалить
2. X - список из которого удаляются элементы. 
3. L - выходящее значение

Сначала запускается обратный счетчик, как в императивных языках for. Далее, пока не закончится список или N не достигнет нуля, запускаем рекурсивно данный предикат.

***

`deletefirst_N(N,[Y],[Z])` - делает то же самое, что и `deleteFitstN`, но реализовано при помощи стандартных предикатов *prolog*

Примеры использования:
```prolog
?- deletefirst_N(3,[1,2,3],L).
L = [] ;

?- deletefirst_N(3,[1,2,3,4],L).
L = [4] ;

?- deletefirst_N(3,[1,2,3,4,5],L).
L = [4, 5] ;
```

Реализация:
```prolog
deletefirst_N(N,L,X) :- append(Z,X,L), length(Z,N).
``` 
С помощью `append` удаляем ненужные нам элементы, при этом указав, что длина удаляемого списка должна быть равна N.

## Задание 1.2: Предикат обработки числового списка
 
`eq(X,Y,Z)` - в числовом списке лексикографически сравнивает их.
 
Примеры использования:
 ```prolog
?- eq([1,2],[1,2],Z).
Z = "=" ;
false.

?- eq([1,2],[1,2,3],Z).
Z = "<" ;
false.

?- eq([1,2,4],[1,2,3],Z).
Z = ">" ;
false.

?- eq([1],[],Z).
Z = ">".

?- eq([],[1],Z).
Z = "<".

?- eq([2,2,3],[1,2,3],Z).
Z = ">" ;
 ```
 
 Реализация:
 ```prolog
eq_task([X|L1],[Y|L2],_,Z):-
    X < Y, eq_task(L1,L2,0,Z).
eq_task([X|L1],[Y|L2],_,Z):-
    X > Y, eq_task(L1,L2,2,Z).
eq_task([X|L1],[Y|L2],_,Z):-
    X = Y, eq_task(L1,L2,1,Z).
eq_task([],[],0,Z):-
    Z = "<".
eq_task([],[],2,Z):-
    Z = ">".
eq_task([],[],1,Z):-
    Z = "=".
eq_task([_|_],[],_,Z):-
    Z = ">".
eq_task([],[_|_],_,Z):-
    Z = "<".

eq(X,Y,Z):-
    eq_task(X,Y,1,Z).
 ```

***

`eq_1(X,Y,Z)` - в числовом списке лексикографически сравнивает их.
 
Примеры использования:
 ```prolog
?- eq_1([1,2],[1,2],Z).
Z = "=" ;
false.

?- eq_1([1,2],[1,2,3],Z).
Z = "<" ;
false.

?- eq_1([1,2,4],[1,2,3],Z).
Z = ">" ;
false.

?- eq_1([1],[],Z).
Z = ">".

?- eq_1([],[1],Z).
Z = "<".

?- eq_1([2,2,3],[1,2,3],Z).
Z = ">" ;
 ```
 
 Реализация:
 ```prolog
eq_1([],[],U):-
    U = "=".
eq_1(X,Y,U):-
    len(X,N1), len(Y,N2), N1 < N2, U = "<".
eq_1(X,Y,U):-
    len(X,N1), len(Y,N2), N1 > N2, U = ">".
eq_1([X|L1],[Y|L2],U):-
    len([X|L1],N1), len([Y|L2],N2), N1 = N2, X < Y, U = "<".
eq_1([X|L1],[Y|L2],U):-
    len([X|L1],N1), len([Y|L2],N2), N1 = N2, X > Y, U = ">".
eq_1([X|L1],[Y|L2],U):-
    len([X|L1],N1), len([Y|L2],N2), N1 = N2, X = Y, eq_1(L1,L2,U).
 ```
Реализация очень простая - сначала смотрим на длины списков. Если они отличаюся, то выдаем в ответе нужный знак.
Если списки одинакового размера, то смотрим на элементы. Если они отличаются, то пишем соответствующий знак. Если нет, идем дальше по рекурсии, пока списки не закончатся, или не встретим разные элементы

***

`deletefirst_N_in_bigger_list(N,L1,L2,L)` - удаляет заданное количество элементов из лексикографически большего списка.

Пример использования:
```prolog
?- deletefirst_N_in_bigger_list(2,[1,2,3,4,5],[1,2,5],L).
L = [3, 4, 5] ;
false.

?- deletefirst_N_in_bigger_list(2,[1,2,3,4,5],[],L).
L = [3, 4, 5] ;
false.

?- deletefirst_N_in_bigger_list(2,[],[],L).
is equal
true 
false.

?- deletefirst_N_in_bigger_list(2,[2,3,4,5],[1,2,3,4],L).
L = [4, 5] ;
false.
```

```prolog
deletefirst_N_in_bigger_list(N,L1,L2,L):-
    eq_1(L1,L2,U), U == "<", deletefirst_N(N,L2,L).
deletefirst_N_in_bigger_list(N,L1,L2,L):-
    eq_1(L1,L2,U), U == ">", deletefirst_N(N,L1,L).
deletefirst_N_in_bigger_list(_,L1,L2,_):-
    eq_1(L1,L2,U), U == "=", write("is equal ").
```


Сначала через предикат `eq_1` ищется больший лексикографически список.
Потом из большего списка убирается первые *N* элементов с помощью предиката `deletefirst_N`.  

***
`task(X)` - найдя на просторах интернета задачку, решили мы с Глушатовым Игорем сделать ее на прологе, посчитав это лучшим языком для решения подобной задачи.
Описание задачи:
На вход программе подается число - количество скобочек. Нужно вывести все возможные компинации открывающихся и закрывающихся скобочек.

Пример использования:
```prolog
?- task(3).
()()()
()(())
(())()
(()())
((()))
true ;
false.

?- task(5).
()()()()()
()()()(())
()()(())()
()()(()())
()()((()))
()(())()()
()(()())()
()(()()())
()(()(()))
()((()))()
()((())())
()((()()))
()(((())))
(())()()()
(()())()()
(()()())()
(()()()())
(()()(()))
(()(()))()
(()(())())
(()(()()))
(()((())))
((()))()()
((())())()
((())()())
((()()))()
((()())())
((()()()))
((()(())))
(((())))()
(((()))())
(((())()))
(((()())))
((((()))))
true ;
false.
```

Реализация:
```prolog
makeSk(0, '').
makeSk(N, X) :- N>0, N1 is N-1, makeSk(N1, R), concat('()', R, X).
makeSk(N, X) :- N>0, N1 is N-1, makeSk(N1, R), concat(R, '()', X).
makeSk(N, X) :- N>0, N1 is N-1, makeSk(N1, R), concat('(', R, R1), concat(R1, ')', X).

skopks(N, X) :- setof(H, makeSk(N, H), X).

print([H|[]]) :- write(H), nl.
print([H|T]) :- print(T), write(H), nl.

task(N) :- skopks(N, X), print(X).
```

Тут есть 3 вида предикатов: 
1. `makeSk` составляет скобочки. Этим занимается встроенный предикат `concat`.
2. `skipks` убирает все похожие ситуации. Это делается с помощью предиката `setof`
3. `print` пишет результат.

4-ый предикат `task` запускает эти 3 типа.

## Задание 2: Реляционное представление данных
Опишите, в чем преимущества и недостатки реляционного представления в целом, и конкретного представления, которое вы использовали.

Преимущества состоят в том, что данный способ представления бд очень легко программировать. Особенно на языках логического типа.
Недостатки состоят в том, что описание какого-либо объекта занимает очень много места. И человеку сложно воспринимать такую информацию.

`task1()` - Получить таблицу групп и средний балл по каждой из групп.

Пример использования:
```prolog
?- task1().
group 101
3.9
group 102
3.7777777777777777
group 103
3.7708333333333335
group 104
3.861111111111111
true.
```

Реализация:
```prolog
task1() :- findall(H,student(H,_),L1), sort(L1,L), select_gr(L).

select_gr([]).
select_gr([X|T]):-
    write("group "), write(X), nl, findall(Z,student(X,Z),L1), rating(L1,[]), select_gr(T).

rating([],List):-
    length(List, Int), mid_rate(List,Int,0).
rating([X|T],List):-
    findall(H,grade(X,_,H),L), append(List,L,L1), rating(T,L1).

mid_rate([],Len,Sum):-
    Ans is Sum / Len, write(Ans), nl.
mid_rate([X|T], Len, Sum):-
    Sum1 is X + Sum, mid_rate(T,Len,Sum1).
```
Сначала мы выуживаем все группы, чтобы можно было как-то их отделить. Далее из полученного списка получаем список студентов из нашей группы.
Далее идет сбор всех оценок в один большой список. После всего считается результат. Он считается путем подсчета суммы всех оценок,
поделенное на количество элементов в списке.
***

`task2()` - Для каждого предмета получить список студентов, не сдавших экзамен (grade=2)

Пример использования:
```prolog
?- task2().
Логическое программирование
[Запорожцев,Эфиркина,Текстописов]

Математический анализ
[Запорожцев,Круглосчиталкин,Густобуквенникова,Криптовалютников,Блокчейнис,Азурин]

Функциональное программирование
[Криптовалютников]

Информатика
[Эфиркина,Джаво,Безумников]

Английский язык
[Эфиркина]

Психология
[Биткоинов,Текстописова,Криптовалютников,Азурин,Вебсервисов]

true.
```

Реализация:
```prolog
task2() :- findall(H,subject(H,_),L), grade2(L).

grade2([]).
grade2([X|T]):-
    subject(X,Sub), write(Sub), nl, findall(H,grade(H,X,2),L), write(L), nl,nl, 
    grade2(T).
```
Тут все просто. Сначала парсим предметы, получая их аббревиатуры. Далее из полученного списка ищем всех, кто получил 2.
Выводим на экран полученный список.
***


`task3()` - Найти количество не сдавших студентов в каждой из групп

Пример использования:
```prolog
?- task3().
group 101
2

group 102
4

group 103
3

group 104
4

true.

```

Реализация:
```prolog
task3() :- findall(H,student(H,_),L1), sort(L1,L), select_gr1(L).

select_gr1([]).
select_gr1([X|T]):-
    write("group "), write(X), nl, findall(Z,student(X,Z),L1), fgrade2(L1,[]), select_gr1(T).


fgrade2([],List):- sort(List,L), length(L,N), write(N), nl,nl.
fgrade2([X|T],List):-
    findall(X,grade(X,_,2),L), append(List,L,L1), fgrade2(T,L1).
```
Данное задание легко строить из реализаций `task2()` и `task1()`. Немного модифицировав код, а именно добавив встроенный предикат `length`
при выводе ответа. В целом принцип работы остался тем же. 


## Выводы
Благодаря проделанной работе, я: 

  - научился создавать сложные предикаты на языке *prolog*, также узнал о том, что в этом языке присутствует динамическое составление предикатов.
  - Узнал о том, что такое список и как им пользоваться. 
  - Узнал о встроенных полезных функциях пролога, научился работать с внешними файлами, строками и с разными базами данных, написанныена языке пролог.
  - Впервые ощутил большую разницу между декларотивными и императивными языкоми.
