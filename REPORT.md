# Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Глушатов И.С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Методы поиска в пространстве состояний решают задачи исскуственного интеллекта. Выделяют два вида методов поиска: неинформативный и информативный. В данной лабораторной
работе рассматриваются методы из первой категории. Алгоритмы из первой группы занимаются перебором всех возможных состояний, пока не найдется целевое (чтобы ускорить процесс и
избежать зацикливаний, перебираются только новые состояния, которых не было до этого). Для того, чтобы решать такие задачи, переходы из одного состояния в другие должны быть
четко описаны, не иметь никаких случайностей. Такие переборные алгоритмы оказываются плохими, если количество вариантов перехода из одного состояния в другое огромно.
Информативные же методы поиска используют дополнительную информацию о полезности того или иного перехода. Примером служит взвешенный граф. Такие методы также называют эвристическими. Поиск производится с учетом приоритетов, поэтому решения находятся быстро даже при большом количестве вариантов перехода.

Prolog оказывается удобным в решении таких задач, в особенности поиск в глубину, так как он является родным для данного языка программирования. Backtracking позволяет
перебирать решения не явно, что также способствует удобному написанию алгоритмов поиска на Prolog'e.

## Задание

Вдоль доски расположены лунки, в каждой из которых лежит черный или белый шар. 
Одним ходом можно менять местами два соседних шара. 
Добиться того, чтобы сначала шли белые шары, а за ними - черные. 
Решить задачу за наименьшее число ходов

## Принцип решения

Так как моя задача была на пространство состояний, я представил лунки как список, состоящий из термов b,w, которые обозначают цвет лежащего в лунке шара. Пример списка:
`[b, w, w, b, w, b, w]`. Состоянием являлась определенная последовательность шаров. Так как мы можем поменять любые два соседних шара, то предикат move выглядит так:

```prolog
move(LIST, RES) :- append(X,[A,B|Y],LIST), append(X, [B,A|Y], RES).
```

Так как мы можем поменять только два соседних шара, то move будет выдавать n-1 решение, включая даже состояния, когда мы меняем два шара одинаковых цветов. Однако в алгоритмах
поиска такие случаи не будут рассматриваться из-за списка уже просмотренных решений, которые не могут повторяться.

```
?- move([b,w,b,w], X).
X = [w, b, b, w] ;
X = [b, b, w, w] ;
X = [b, w, w, b] ;
false.
```

Предикат `prolong` продлевает путь в графе, т.е. добавляет новое состояние в соответствии с предикатом `move`, которого еще не было в пути.

```prolog
prolong([X|T], [Y,X|T]) :- move(X,Y), not(member(Y,[X|T])).
```

Поиск в ширину и глубину реализованы стандартным для Prolog'а способом. Единственное отличие, что первый аргумент предиката `breadth_first_search` имитирует очередь, а у
`depth_first_search` - стэк. Т.е. в первом случае пройденные пути добавляются в конец, а извлекаются с начала, а во втором и добавляются, и извлекаются с начала. Стоит
заметить, что алгоритмы поиска в Prolog идейно очень похожи на алгоритмы на императивных языках программирования.

```prolog
% поиск в ширину
bfs(X, Y, P) :- breadth_first_search([[X]], Y, P).
breadth_first_search([[X|T]|_], X, [X|T]).
breadth_first_search([P|QI], X, R) :- findall(Z, prolong(P,Z), T), 
									append(QI, T, QO), !, 
									breadth_first_search(QO, X, R). 
breadth_first_search([_|T], Y, L) :- breadth_first_search(T,Y,L).

% поиск в глубину
dfs(X, Y, P) :- depth_first_search([[X]], Y, P).
depth_first_search([[X|T]|_], X, [X|T]).
depth_first_search([P|QI], X, R) :- findall(Z, prolong(P,Z), T), 
									append(T, QI, QO), !,
									depth_first_search(QO, X, R).
depth_first_search([_|T], Y, L) :- depth_first_search(T,Y,L).
```

Поиск с итерационным углублением представляет из себя поиск в глубину с ограничением высоты. Так как генерация целых чисел (высоты) в прологе потенциально бесконечна, то я
поставил отсечение в конце предиката, чтобы выдавался только первый найденный ответ.

```prolog
% поиск с итерационным углублением
search_id(X,Y,P) :- int(LIM), search_id(X, Y, P, LIM), !.
search_id(X,Y,P,LIM) :- depth_id([X], Y, P, LIM).

int(1).
int(N) :- int(M), N is M+1.

depth_id([X|T],X,[X|T], 0).
depth_id(X,Y,P,LIM) :- LIM>0, prolong(X, XX), LIM1 is LIM-1, depth_id(XX, Y, P, LIM1).
```

## Результаты

Время я вычислял с помощью встроенного предиката `get_time`. Результат выглядил так:

```prolog
?- get_time(BEGIN), search_id([w,b,b,b,w,b,w,b], [w,w,w,b,b,b,b,b], X), get_time(END), print(X), TIME is END - BEGIN.
[[w,w,w,b,b,b,b,b],[w,w,b,w,b,b,b,b],[w,w,b,b,w,b,b,b],[w,w,b,b,b,w,b,b],[w,w,b,b,b,b,w,b],[w,b,w,b,b,b,w,b],[w,b,b,w,b,b,w,b],[w,b,b,b,w,b,w,b]]
BEGIN = 1606654920.0199633,
X = [[w, w, w, b, b, b, b, b], [w, w, b, w, b, b, b|...], [w, w, b, b, w, b|...], [w, w, b, b, b|...], [w, w, b, b|...], [w, b, w|...], [w, b|...], [w|...]],
END = 1606654920.0379462,
TIME = 0.017982959747314453.
```

| Тесты | Алгоритм поиска |  Длина найденного первым пути  |  Время работы  |
|-------|-----------------|--------------------------------|----------------|
|[w,b,w,b,w,b,w,b]| В ширину | [[w,w,w,w,b,b,b,b],[w,w,w,b,w,b,b,b],[w,w,w,b,b,w,b,b],[w,w,w,b,b,b,w,b],[w,w,b,w,b,b,w,b],[w,w,b,b,w,b,w,b],[w,b,w,b,w,b,w,b]] | 0.512601375579834 |
|                 | В глубину | [[w,w,w,w,b,b,b,b],[w,w,w,b,w,b,b,b],[w,w,b,w,w,b,b,b],[w,b,w,w,w,b,b,b],[b,w,w,w,w,b,b,b],[b,w,w,w,b,w,b,b],[w,b,w,w,b,w,b,b],[w,w,b,w,b,w,b,b],[w,w,w,b,b,w,b,b],[w,w,w,b,b,b,w,b],[w,w,b,w,b,b,w,b],[w,b,w,w,b,b,w,b],[b,w,w,w,b,b,w,b],[b,w,w,w,b,b,b,w],[w,b,w,w,b,b,b,w],[w,w,b,w,b,b,b,w],[w,w,b,b,w,b,b,w],[w,b,w,b,w,b,b,w],[b,w,w,b,w,b,b,w],[b,w,w,b,b,w,b,w],[w,b,w,b,b,w,b,w],[w,b,b,w,b,w,b,w],[b,w,b,w,b,w,b,w],[b,b,w,w,b,w,b,w],[b,b,w,w,b,b,w,w],[b,w,b,w,b,b,w,w],[w,b,b,w,b,b,w,w],[w,b,b,b,w,b,w,w],[b,w,b,b,w,b,w,w],[b,b,w,b,w,b,w,w],[b,b,b,w,w,b,w,w],[b,b,b,w,w,w,b,w],[b,b,w,b,w,w,b,w],[b,w,b,b,w,w,b,w],[w,b,b,b,w,w,b,w],[w,b,b,b,w,w,w,b],[b,w,b,b,w,w,w,b],[b,b,w,b,w,w,w,b],[b,b,w,w,b,w,w,b],[b,w,b,w,b,w,w,b],[w,b,b,w,b,w,w,b],[w,b,b,w,w,b,w,b],[b,w,b,w,w,b,w,b],[b,w,w,b,w,b,w,b],[w,b,w,b,w,b,w,b]] | 0.0030210018157958984 |
|                 | ID | [[w,w,w,w,b,b,b,b],[w,w,w,b,w,b,b,b],[w,w,w,b,b,w,b,b],[w,w,w,b,b,b,w,b],[w,w,b,w,b,b,w,b],[w,w,b,b,w,b,w,b],[w,b,w,b,w,b,w,b]] | 0.006013154983520508 |
|[w,b,b,b,w,b,w,b]| В ширину | [[w,w,w,b,b,b,b,b],[w,w,b,w,b,b,b,b],[w,w,b,b,w,b,b,b],[w,w,b,b,b,w,b,b],[w,w,b,b,b,b,w,b],[w,b,w,b,b,b,w,b],[w,b,b,w,b,b,w,b],[w,b,b,b,w,b,w,b]]| 1.623502254486084 |
|                 | В глубину | [[w,w,w,b,b,b,b,b],[w,w,b,w,b,b,b,b],[w,b,w,w,b,b,b,b],[b,w,w,w,b,b,b,b],[b,w,w,b,w,b,b,b],[w,b,w,b,w,b,b,b],[w,w,b,b,w,b,b,b],[w,w,b,b,b,w,b,b],[w,b,w,b,b,w,b,b],[b,w,w,b,b,w,b,b],[b,w,w,b,b,b,w,b],[w,b,w,b,b,b,w,b],[w,b,b,w,b,b,w,b],[b,w,b,w,b,b,w,b],[b,b,w,w,b,b,w,b],[b,b,w,w,b,b,b,w],[b,w,b,w,b,b,b,w],[w,b,b,w,b,b,b,w],[w,b,b,b,w,b,b,w],[b,w,b,b,w,b,b,w],[b,b,w,b,w,b,b,w],[b,b,b,w,w,b,b,w],[b,b,b,w,b,w,b,w],[b,b,w,b,b,w,b,w],[b,w,b,b,b,w,b,w],[w,b,b,b,b,w,b,w],[w,b,b,b,b,w,w,b],[b,w,b,b,b,w,w,b],[b,b,w,b,b,w,w,b],[b,b,b,w,b,w,w,b],[b,b,b,w,w,b,w,b],[b,b,w,b,w,b,w,b],[b,w,b,b,w,b,w,b],[w,b,b,b,w,b,w,b]] | 0.0039882659912109375 |
|                 | ID | [[w,w,w,b,b,b,b,b],[w,w,b,w,b,b,b,b],[w,w,b,b,w,b,b,b],[w,w,b,b,b,w,b,b],[w,w,b,b,b,b,w,b],[w,b,w,b,b,b,w,b],[w,b,b,w,b,b,w,b],[w,b,b,b,w,b,w,b]] | 0.017982959747314453 |

Как мы можем увидеть, поиск в ширину самый медленный, однако его достоинство в том, что если решений несколько, то первым обязательно выдаст кратчайшее. Поиск в глубину же
работает очень быстро, но находит не оптимальные пути. Однако в ходе экспериментов я увидел, что если я захочу получить еще решения, то поиск в глубину будет медленнее, чем
поиск в ширину, который после нахождения первого дает мгновенно остальные. Поиск с итерационным углублением совмещает в себе эти подходы, затрачиваясь лишь на проходы по тем путям, где уже был раньше, не запоминая результаты предыдущих решений, однако такое допущение, как мы видим не сильно складывается на производительности.

## Выводы

В ходе лабораторной работы я узнал, что множество задач на пространство состояний можно легко решать с помощью представления окружающей действительности в виде графа. Это открыло мне новое видение на алгоритмизацию решений ряда задач. Пользуясь полученными знаниями, я успел решить задачу на поиск минимального количества цветов для закраски
областей карты таким образом, чтобы две соседнии были разных цветов. Третья лабораторная работа позволила мне закрепить знания о поисках в ширину и глубину, о которых я узнал
за несколько дней до выдачи. А новый для меня алгоритм поиска с итеративным углублением произвел впечатление из-за своей эффективности и результативности.


