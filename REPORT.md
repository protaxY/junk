# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Юревич В.Ю.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Списки в Прологе являются исключительно односвязными. Отсутсвует явная работа с указателями на последующие элементы списка.

## Задание 1.1: Предикат обработки списка

`task1_11(X, N, R)` - предикат осуществляет удаление элемента с заданным номером из списка.

Примеры использования:
```prolog
?- task1_11([a,b,c,g,e,r], 4, R).
R = [a, b, c, e, r] ;
false.

?- task1_11([g,e,r], 7, R).
false.

?- task1_11([g,e,r], 0, R).
false.

?- task1_11([g,e,r], 3, R).
R = [g, e] ;
false.
```

Реализация:
```prolog
remove_head([Y|X], Y, X).
plus_head(X, Y, [X|Y]).

task1_11([_|Y], 1, Y).
task1_11(X, N, R) :-  remove_head(X, R1, X1), N1 is N - 1, task1_11(X1, N1, R2), plus_head(R1, R2, R).
```

На вход предикату поступает список и номер элемента, который необходимо удалить, резульатом является список без элемента,
находившегося под этим номером или "false.", если в списке отсутсвовал элемент с таким номером.
Предикат рекурсивно отделет голову от хвоста, уменьшает на единицу номер элемента, который необходимо удалить, предикат
вызвает сам себя, в качестве списка передаётся хвост, затем объединяет голову и список, который возвращает рекурсивный вызов.
Условием выхода из рекурсии является значение номера удаляемого элемента равное единице, после чего возвращается только хвост
без головы полученного списка.

## Задание 1.2: Предикат обработки числового списка

`task1_15(X, N)` - предикат вычисляет номер первого отрицательного элемента в списке.

Примеры использования:
```prolog
?- task1_15([1, 4, 5, 6, -11, 9 , 10 , 5], N).
N = 5 ;
false.

?- task1_15([1, 2, -3, 5], 3).
true ;
false.

?- task1_15([4, 7, 114, 7, 9, 13], X).
false.
```

Реализация:
```prolog
task1_15([X|_], N) :- X < 0, N is 1.
task1_15([X|Y], N) :- X > 0, task1_15(Y, N1), N is N1 + 1.
```
Предикат отделяет голову от хвоста списка, проверяет является ли значение головы отрицательным, если нет, то
происходит рекурсивный вызов, и номер отрицательного элемента вычисляется как номер полученный из рекурсивного вызова
плюс единица. Условием выхода из рекурсии является отрицательно значение в голове списка.

## Задание 2: Реляционное представление данных

Недостатком такого реляционного представления данных является его громоздскость, что усложняет прямое взаимодействие с данными
непосредственно человеком. В случае использования правильно написанных предикатов, которые в свою очередь
достаточно легко программируются, взаимодействие значительно облегчается, что является очевидным плюсом.

`task2_1 ` - предикат вычисляет средний бал для каждого предмета.

Примеры использования:
```prolog
?- task2_1.
Средняя оценка по предмету Английский язык = 3.75
Средняя оценка по предмету Информатика = 3.9285714285714284
Средняя оценка по предмету Логическое программирование = 3.9642857142857144
Средняя оценка по предмету Математический анализ = 3.892857142857143
Средняя оценка по предмету Психология = 3.9285714285714284
Средняя оценка по предмету Функциональное программирование = 3.9642857142857144
false.
```

Реализация:
```prolog
spisok_predmetov(L) :- findall(X, grade(_, _, X, _), L1), sort(L1, L).

vse_ocenki_po_kajdomy_predmety(O) :-
   spisok_predmetov(L),
   member(H, L),
   findall(X, grade(_, _, H, X), O),
   write('Средняя оценка по предмету '),
   write(H).

summa_spiska([H], H, 1).
summa_spiska(X, V, L) :- append([H], B, X), summa_spiska(B, V1, L1), V is V1 + H, L is L1 + 1.

sr_arf(X, R) :- summa_spiska(X, V, L), R is V / L.

task2_1 :-
    vse_ocenki_po_kajdomy_predmety(O),
    sr_arf(O, X),
    tab(1),
    write('= '),
    write(X),
    nl,
    false.
```

Предикат вызвает предикат "vse_ocenki_po_kajdomy_predmety", который в свою очередь обращается к предикату
"spisok_predmetov", получает список из оценок по каждому предмету и с помощью предикатов "summa_spiska" и
"sr_arf" вычисляет средннюю оценку для каждого из предметов.

`task2_2` - предикат вычисляет средний бал для каждого предмета.

Примеры использования:
```prolog
?- task2_2.
Количество не сдавших студентов в группе 101 = 2
Количество не сдавших студентов в группе 102 = 5
Количество не сдавших студентов в группе 103 = 3
Количество не сдавших студентов в группе 104 = 2
false.
```

Реализация:
```prolog
spisok_gryp(L) :- findall(X, grade(X, _, _, _), L1), sort(L1, L).

task2_2 :-
    spisok_gryp(L),
    member(H, L),
    findall(X1, grade(H, X1, _, 2), X2),
    sort(X2, X3),
    length(X3, X),
    write('Количество не сдавших студентов в группе '),
    write(H),
    tab(1),
    write('= '),
    write(X),
    nl,
    false.
```

С помощью предиката "spisok_gryp", получаем список всех групп, с помощью предиката "findall" получаем список из всех учеников соответсвующей группы,
получивших 2, сортируем его, чтобы избавиться от повторов в списке, так как один ученик мог получить 2 по нескольким предметам сразу,
после вычисляем длинну получившегося списка. 

`task2_3 ` - предикат находит количество не сдавших студентов для каждого предмета.

Примеры использования:

```prolog
?- task2_3.
Количество не сдавших студентов по предмету Английский язык = 4
Количество не сдавших студентов по предмету Информатика = 2
Количество не сдавших студентов по предмету Логическое программирование = 2
Количество не сдавших студентов по предмету Математический анализ = 3
Количество не сдавших студентов по предмету Психология = 1
Количество не сдавших студентов по предмету Функциональное программирование = 1
false.

```

Реализация:
```prolog
spisok_predmetov(L) :- findall(X, grade(_, _, X, _), L1), sort(L1, L).

task2_3 :-
    spisok_predmetov(L),
    member(H, L),
    findall(X1, grade(_, X1, H, 2), X2),
    length(X2, X),
    write('Количество не сдавших студентов по предмету '),
    write(H),
    tab(1),
    write('= '),
    write(X),
    nl,
    false.
```
С помощью предиката "spisok_predmetov", получаем список всех предметов, с помощью предиката "findall" находим всех
студентов получивших 2 по конкретному предмету, зачем вычисляем длинну этого списка с помощью предиката "length".


## Выводы

Выполнение лабораторной работы познакомило меня с работой со списками на языке Пролог, я также узнал о некоторых встроенных
предикатах, получил опыт взаимодействия с реляционным представлением данных. Тот что один и тот
же предикат, может выполнять несколько задач в зависимости от унификации переменых, меня искрене удивил.
Так как эти задачи могли совершенно не учитываться при написании предиката, такой результат очень мало вероятен при
работе с императивными языками программирования. Пример: предикат "member(X, Y)", изначально созданн для определения
является ли элемент X элементом списка Y, но при унификации только переменной Y, переменная X будет унифицироваться
каждым элементом списка, что не было изначальной целью при создании предиката.




